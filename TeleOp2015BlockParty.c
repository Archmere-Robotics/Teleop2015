#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,    HTSMux,         sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          sweeper,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          heartbeat,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     wheelC,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     wheelD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     wheelB,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     wheelA,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     collectorMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     liftMotor,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    rightHook,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    dumpServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    rightIRServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_6,    leftIRServo,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//KING OF PREPROCESSING!!!!
//include stuff only once
#pragma once
#include "TeleOp2015BlockParty.h"
#ifndef _TELEOP2015
#define _TELEOP2015

void init(){
	Stop();//stop all of the robot's motors
	moveConveyor(false);
	setDump(0);//flatten the PVC thing
	setRightHook(false);
	activateServos();
	updateServos();//magic
	//reset motor encoders
	nMotorEncoder[liftMotor]=0;
	nMotorEncoder[wheelA]=0;
	nMotorEncoder[wheelB]=0;
	nMotorEncoder[wheelC]=0;
	nMotorEncoder[wheelD]=0;
	return;
}
void drive(){
	getJoystickSettings(joystick);//poll joystick
	if(abs(joystick.joy1_x1) >= joyTol || abs(joystick.joy1_y1) >= joyTol) {//determines if the drive joystick is moved. If so, move the robot.
		//make the joysticks floats, and make them nonlinear
		float j1x1=pow((joystick.joy1_x1/128.0),3)*MOTOR_MAX;
		float j1y1=pow((joystick.joy1_y1/128.0),3)*MOTOR_MAX;
		//sends the values to the motor control library.
		addVector(j1x1,j1y1);
	}
	//determine whether the rotation joystick has been moved.
	if(abs(joystick.joy1_x2) >=joyTol)
		addRotation(pow((joystick.joy1_x2/128.0),3)*MOTOR_MAX);

	//rotate robot with buttons on the back of the controller
	if(joy1Btn(8))
		addRotation(50);
	if(joy1Btn(7))
		addRotation(-50);
	//no idea why 18, but it works
	if(joy1Btn(6))
		addRotation(25);
	if(joy1Btn(5))
		addRotation(-25);
	//move the robot in a straight line with the tophat
	switch(joystick.joy1_TopHat){
	case 0://up
		addVector(0,FCC);
		break;
	case 1://up right
		addVector(FCC,FCC);
		break;
	case 2://right
		addVector(FCC,0);
		break;
	case 3://down right
		addVector(FCC,-FCC);
		break;
	case 4://down
		addVector(0,-FCC);
		break;
	case 5://down left
		addVector(-FCC,-FCC);
		break;
	case 6://left
		addVector(-FCC,0);
		break;
	case 7://up left
		addVector(-FCC,FCC);
		break;
	}
	//tell the motor control library to actually move the robot.
	loadVal();
}
//update the servos & non-drivetrain motors
void udServos(){
	//control the hooks on the sides of the robot
/*	if(joy2Btn(1))
		motor[hook]=HOOK_POWER;
	else if(joy2Btn(2))
		motor[hook]=-HOOK_POWER;
	else
		motor[hook]=0;*/
	if(joy2Btn(1))
		setRightHook(true);
	else if(joy2Btn(2))
		setRightHook(false);

	if(joy2Btn(4))
		motor[sweeper]=SWEEPER_POWER;
	else if(joy2Btn(3))
		motor[sweeper]=-SWEEPER_POWER;
	else
		motor[sweeper]=0;

	//move lift
	if(joy2Btn(5))
		setLiftPos(-1,false);//down
	else if(joy2Btn(6))
		setLiftPos(1,true);//up
	else
		setLiftPos(0,true);//stop if no button is pressed

	//control conveyor
	if(joy2Btn(7))
		moveConveyor(CONVEYOR_UP);//intake
	else if(joy2Btn(8))
		moveConveyor(CONVEYOR_DOWN);//outtake
	else
		moveConveyor(CONVEYOR_STOP);

	if(abs(joystick.joy2_x1)>joyTol)
		setDump(joystick.joy2_x1/-6);
	else
		//tilt the PVC carrier thing
		setDump(10);

	//move the conveyor also with the joystick
	if(abs(joystick.joy2_y2)>joyTol)
		moveConveyor(joystick.joy2_y2);

		//do magical things with the MC library
		updateServos();
}
//update the heartbeat sensor value (motor A)
void updateLight(){
	//loops from -100 to 100
	motor[heartbeat]=(lightVal=((++lightVal)%200))-100;
}
task main() {
	init();
	waitForStart();
	while(true){
		udServos();
		drive();
		updateLight();
		alive();
	}
}
#endif
